# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Original Step-score
#'
#' Computes the original step-score from a solution to another.
#'
#' This function can only be called after \link{solutions} has been called
#' or at least \link{takeGraph}, to create the data structure which 
#' contain the score distributions. \cr
#' Only the number of red and blue samples altered in the start and finish
#' solutions are needed. The corresponding solutions do not have to 
#' actually exist.
#'
#' @param r0 The number of red samples to start from
#' @param b0 The number of blue samples to start from
#' @param r1 The number of red samples to get to
#' @param b1 The number of blue samples to get to
#' @return the step-score value. If the parameters have meaningless values 
#' (negative or greater than the number of red/blue samples) the result is -1.
#' @export
singleStepScore <- function(r0, b0, r1, b1) {
    .Call('_musette_singleStepScore', PACKAGE = 'musette', r0, b0, r1, b1)
}

#' Get Ready to Work with This Graph
#'
#' This is an inner function, called by other R functions in this
#' package, but it is left available for the expert user or developer.
#'
#' Set Some Internal Global Variables to Deal with a Given Graph : 
#' the degree distribution of the alterations, the lists of neighbours,
#' the number of alterations, and the memo that will contain score
#' distribution tables used for step-score computation.
#'
#' @param data A vector of integer vectors. \code{data[[i]]} should be an integer vector containing the ids of the samples hit by alteration \code{i}
#' @return nothing.
#' @family inner functions
#' @export
takeGraph <- function(data) {
    invisible(.Call('_musette_takeGraph', PACKAGE = 'musette', data))
}

#' Get Ready to Work with These Groups
#'
#' This is an inner function, called by other R functions in this
#' package, but it is left available for the expert user or developer.
#'
#' Set Some Internal Global Variables to Deal with a Given Grouping of
#' the Samples : number of red/blue samples and the groups themselves.
#'
#' @param red A logical vector. \code{red[[i]]} should be true iff sample \code{i} is red
#' @param blue A logical vector. \code{blue[[i]]} should be true iff sample \code{i} is blue
#' @return nothing.
#' @family inner functions
#' @export
takeGroups <- function(red, blue) {
    invisible(.Call('_musette_takeGroups', PACKAGE = 'musette', red, blue))
}

#' Perform One Growth Step of the Solution Tree
#'
#' This is an inner function, called by other R functions in this
#' package, but it is left available for the expert user or developer.
#'
#' Increase the step-core threshold to the next possible value (which is the
#' step-score of the first node in the waiting queue). This allows one or 
#' many nodes to be added to the solution tree.
#'
#' @return nothing.
#' @family inner functions
#' @export
growTree <- function() {
    invisible(.Call('_musette_growTree', PACKAGE = 'musette'))
}

#' Create a Dataframe From the Solution Tree
#'
#' This is an inner function, called by other R functions in this
#' package, but it is left available for the expert user or developer.
#'
#' Gather information about the nodes contained in it and write them to
#' A dataframe. Note that it only contains numbers, which will later
#' have to be translated by R code into names, unknown to C++ code.
#'
#' @return nothing.
#' @family inner functions
#' @export
encodeSolutionTree <- function() {
    .Call('_musette_encodeSolutionTree', PACKAGE = 'musette')
}

#' Pass a Step-score Mode to the C++ Code
#'
#' This is an inner function, called by other R functions in this
#' package, but it is left available for the expert user or developer.
#'
#' @param stepMode : an integer. 0 for "original", 1 for "best-first", 2 for "strict"
#' @return nothing.
#' @family inner functions
#' @export
takeStepScore <- function(stepMode) {
    invisible(.Call('_musette_takeStepScore', PACKAGE = 'musette', stepMode))
}

#' Reset the Solution Tree
#'
#' This is an inner function, called by other R functions in this
#' package, but it is left available for the expert user or developer.
#'
#' Create a fresh solution tree, empty and ready to be grown, 
#' clearing the previously built solution tree, if necessary.
#'
#' @return nothing.
#' @family inner functions
#' @export
resetSolutionTree <- function() {
    invisible(.Call('_musette_resetSolutionTree', PACKAGE = 'musette'))
}

#' Pass a Tree Size Bound to the C++ code
#'
#' This is an inner function, called by other R functions in this
#' package, but it is left available for the expert user or developer.
#'
#' @param treeSize An integer
#' @return nothing.
#' @family inner functions
#' @export
setBound <- function(treeSize) {
    invisible(.Call('_musette_setBound', PACKAGE = 'musette', treeSize))
}

#' Pass a Step-score Threshold to the C++ Code
#'
#' This is an inner function, called by other R functions in this
#' package, but it is left available for the expert user or developer.
#'
#' @param threshold : An integer
#' @return nothing.
#' @family inner functions
#' @export
setThreshold <- function(threshold) {
    invisible(.Call('_musette_setThreshold', PACKAGE = 'musette', threshold))
}

#' Grow Solution Tree Until a Criterion is Met
#'
#' This is an inner function, called by other R functions in this
#' package, but it is left available for the expert user or developer.
#'
#' The solution tree is grown using \code{\link{growTree}} until
#' its size reaches the set bound, or the step-score threshold reaches
#' the predefined value. 
#'
#' @return nothing.
#' @seealso \code{\link{growTree}}, \code{\link{setThreshold}}, \code{\link{setBound}}
#' @family inner functions
#' @export
fullyGrowTree <- function() {
    invisible(.Call('_musette_fullyGrowTree', PACKAGE = 'musette'))
}

#' Grow Solution Tree Until a Criterion is Met, forget the Solutions, keep the Growth history.
#'
#' This is an inner function, called by other R functions in this
#' package, but it is left available for the expert user or developer.
#'
#' The solution tree is grown using \code{\link{growTree}} until
#' its size reaches the set bound, or the step-score threshold reaches
#' the predefined value. 
#'
#' @return A list showing the values successively taken by the step-score threshold, along
#' with the number of nodes and the number of leaves at each stage.
#' @seealso \code{\link{growTree}}, \code{\link{setThreshold}}, \code{\link{setBound}}
#' @family inner functions
#' @export
exploreTree <- function() {
    .Call('_musette_exploreTree', PACKAGE = 'musette')
}

#' Compute the Domination Relationship in the Current Graph
#'
#' (See details below about what "domination" means) 
#' Compute for every alteration A :
#'   \itemize{
#'     \item the list of alterations dominated by A "loosely" (i.e. including those dominating A)
#'     \item the list of alterations dominated by A "strictly" (i.e. excluding those dominating A)
#'     \item the list of alterations dominating A "loosely" (i.e. including those dominated by A)
#'     \item the list of alterations dominating A "strictly" (i.e. excluding those dominated by A)
#'   }
#' 
#' This is an inner function, called by other R functions in this
#' package, but it is left available for the expert user or developer.
#' 
#' Given a network connecting samples and alterations, and given two groups of samples, red and blue, alteration A
#' will dominate alteration B if : 
#' \itemize{
#'  \item At least <redPercent>\% of the red samples affected by B are also affected by A, 
#'  \item At least <bluePercent>\% of the blue samples affected by A are also affected by B,
#'  \item The loci of A and B lie on the same chromosome, at most <distance> base pairs apart (this part is for alterations which are genomic, and can simply be ignored for other applications)
#' }
#' This is a somewhat more flexible version of the more natual criteria according to which A would dominate B if : 
#' \itemize{
#'  \item The red samples affected by B are also affected by A
#'  \item The blue samples affected by A are also affected by B
#' } 
#' To compute this simpler and more restrictive relation, use \code{redPercent=100} and \code{bluePercent=100}.
#' 
#' @param redPercent The required percentage of red samples
#' @param bluePercent The required percentage of blue samples
#' @param chromosome (for genomic alterations) An integer vector containing the chromosome of each
#' alteration in the current graph (see \code{\link{takeGraph}}). If omitted, this parameter has no effect.
#' @param locus (for genomic alterations) An integer vector with the same length as \code{chromosome}, containing
#' the 'locus' of each alteration (e.g. in base pairs).  If omitted, this parameter has no effect.
#' @param distance The maximum distance accepted between two alterations' loci for
#' domination to take place. If omitted, this parameter has no effect.
#' @return A list \code{l} of 6 named lists of character vectors. If \code{A} is the name of an alteration, then :
#' \itemize{
#' \item \code{l$loose_dominators[[A]]} contains the names of alterations "loosely" dominating \code{A}.
#' \item \code{l$loose_dominated[[A]]} contains the names of alterations "loosely" dominated by \code{A}.
#' \item \code{l$strict_dominators[[A]]} contains the names of alterations "strictly" dominating \code{A}.
#' \item \code{l$strict_dominated[[A]]} contains the names of alterations "strictly" dominated by \code{A}.
#' } 
#' @seealso \code{\link{takeGraph}}, \code{\link{domination.graph}}
#' @family inner functions
#' @export
rawDominationGraphFineTuned <- function(chromosome, locus, distance, redPercent, bluePercent) {
    .Call('_musette_rawDominationGraphFineTuned', PACKAGE = 'musette', chromosome, locus, distance, redPercent, bluePercent)
}

#' Compute Connected Components in a Graph.
#'
#' This is an inner function, called by other R functions in this
#' package, but it is left available for the expert user or developer.
#'
#' @param neighbours An adjacency list in the form of a vector of vectors.
#' @return An integer vector \code{C} such that \code{C[[i]]} is a node in
#' the same component as \code{i}, and \code{C[[i]]=C[[j]]} iff \code{i} and
#' \code{j} are in the same component.
#' @family inner functions
#' @export
connectedComponents <- function(neighbours) {
    .Call('_musette_connectedComponents', PACKAGE = 'musette', neighbours)
}

#' Compute Strongly Connected Components in a Directed Graph.
#'
#' This is an inner function, called by other R functions in this
#' package, but it is left available for the expert user or developer.
#'
#' @details Tarjan's algorithm is used.
#'
#' @param neighbours An adjacency list in the form of a vector of vectors.
#' @return An integer vector \code{C} such that \code{C[[i]]} is a node in
#' the same component as \code{i}, and \code{C[[i]]=C[[j]]} iff \code{i} and
#' \code{j} are in the same component.
#' @family inner functions
#' @export
scc <- function(neighbours) {
    .Call('_musette_scc', PACKAGE = 'musette', neighbours)
}

