library(igraph)
library(visNetwork)

# @export
influenceGraph1 <- function(data,nb,leafs.only=TRUE,nodemaxsize=50,edgemaxwidth=30,main="Influence graph"){
 
  sol<- data
  #sol <- data$solutions
  if (leafs.only){
    sol <- sol[sol$leaf==TRUE,]    
  }
  sol <- sol[order(sol$score,decreasing=TRUE),]       #ordering by decreasing score
  sol <- sol[1:min(nb,dim(sol)[1]),]                  #only the nb first solutions are kept
  
  alterations <- do.call(c,sol$alterations)
  alterations <- unique(alterations)      #list of the alterations present in the selected solutions
  
  #if genes i and j are in the same solution, adj_matsol[i,j] will contain the corresponding score
  adj_matsol <- matrix(0,length(alterations),length(alterations),dimnames=list(alterations,alterations)) 
  
  #matsol(i,j)=TRUE  means that gene i is selected in the jth solution  
  matsol=sapply(sol$alterations,function(s) alterations %in% s)
  
  for (i in 1:length(alterations)){
    for(j in 1:length(alterations)){
      common <- which(matsol[i,]+matsol[j,]==2)     #solutions containing genes i and j
      adj_matsol[i,j] <- sum(sol$score[common])
    }
  }
  
  selected <- which(rowSums(adj_matsol)>0)
  #alt2 <- data$alterations[alterations[selected],]
  net_mat <- adj_matsol[selected,selected]
  g <- graph.adjacency(net_mat,mode="undirected",weighted=TRUE,diag=FALSE)
  V(g)$size <- nodemaxsize*diag(net_mat)/max(diag(net_mat)) 
  V(g)$label <- alterations[selected]
  V(g)$label.cex <- 1
  V(g)$label.color <- "red"
  E(g)$width <- edgemaxwidth*E(g)$weight/max(E(g)$weight)  
  E(g)$color <- "black"
  V(g)$color.border <- 'red'
  V(g)$color.highlight.background <- "rgb(255,253,56)"
  V(g)$color.highlight.border <- "rgb(253,164,41)"
  V(g)$color.hover.background <-  "rgb(255,253,56)"
  V(g)$color.hover.border <- "rgb(253,164,41)"
  V(g)$borderWidthSelected=10
  V(g)$label <- alterations[selected]
  V(g)$label.cex <- 0.8
  V(g)$font.color <- "rgb(49,127,230)"
  V(g)$font.highlight.color <- 'red'
  #V(g)$title <- paste0("<p>", V(g)$label,"<br>band: ",alt2$band, "<br>Individual Score: ", round(alt2[,'score'], 2), "<br>R= ", alt2$nbredneighbours, '/', sol$red.total[1:nrow(alt2)],' - ','B= ',alt2$nbblueneighbours,'/', sol$blue.Total[1:nrow(alt2)],  "</p>")
  # title = paste0("<p>", 1:nb,"<br>Tooltip !</p>")
  
  return(g)  
}

# @export
influenceGraph2 <- function (sol,alt, nb, leafs.only = TRUE, nodemaxsize = 50, edgemaxwidth = 30, 
                             main = "Influence graph") 
{
  if (leafs.only) {
    sol <- sol[sol$leaf == TRUE, ]
  }
  alt <- alt
  sol <- sol[order(sol$score, decreasing = TRUE), ]
  sol <- sol[1:min(nb, dim(sol)[1]), ]
  alterations <- do.call(c, sol$alterations)
  alterations <- unique(alterations)
  matsol <- c()
  adj_matsol <- matrix(0, length(alterations), length(alterations), 
                       dimnames = list(alterations, alterations))
  matsol = sapply(sol$alterations, function(s) alterations %in% 
                    s)
  for (i in 1:length(alterations)) {
    for (j in 1:length(alterations)) {
      common <- which(matsol[i, ] + matsol[j, ] == 2)
      adj_matsol[i, j] <- sum(sol$score[common])
    }
  }
  selected <- which(rowSums(adj_matsol) > 0)
  alt2 <- alt[alterations[selected],]
  net_mat <- adj_matsol[selected, selected]
  col_fun = circlize::colorRamp2(c(0,quantile(alt2$hyper, 0.90)), c(rgb(255, 255, 255, maxColorValue = 255),rgb(255, 0, 0, maxColorValue = 255)))
  g <- graph.adjacency(net_mat, mode = "undirected", weighted = TRUE, 
                       diag = FALSE)
  V(g)$size <- nodemaxsize * diag(net_mat)/max(diag(net_mat))
  V(g)$color.background <- col_fun(alt2$hyper)
  V(g)$color.border <- 'red'
  V(g)$color.highlight.background <- "rgb(255,253,56)"
  V(g)$color.highlight.border <- "rgb(253,164,41)"
  V(g)$color.hover.background <-  "rgb(255,253,56)"
  V(g)$color.hover.border <- "rgb(253,164,41)"
  V(g)$borderWidthSelected=10
  V(g)$label <- alterations[selected]
  V(g)$label.cex <- 0.8
  V(g)$font.color <- "rgb(49,127,230)"
  V(g)$font.highlight.color <- 'red'
  V(g)$title <- paste0("<p>", V(g)$label,"<br>band: ",alt2$band, "<br>Individual Score: ", round(alt2[,'score'], 2), "<br>R= ", alt2$nbredneighbours, '/', sol$red.total[1:nrow(alt2)],' - ','B= ',alt2$nbblueneighbours,'/', sol$blue.Total[1:nrow(alt2)],  "</p>")
  # title = paste0("<p>", 1:nb,"<br>Tooltip !</p>")
  
  E(g)$width <- (edgemaxwidth * E(g)$weight/max(E(g)$weight))/2
  return(g)
}





#' Visualize the Influence of Alterations and Pairs of Alterations in the Top Solutions 
#'
#' Given a solution dataframe generated by \link{solutions} or \link{do.musette}, plot
#' a graph which nodes are the alterations present in a given number of top solutions.
#' The size of each node is proportional to the sum of the scores of the 
#' top solutions containing the correspondant alterations. 
#' An edge means that two alterations are both contained in some top solution,
#' its width beeing proportional to the sum of the score of the solutions they
#' both belong to.   
#'
#' @param data A  dataframe generated using \link{solutions} or \link{do.musette}
#' @param nb The number of top solutions to consider 
#' @param do.musette.object Has the dataframe been generated by do.musette? 
#' @param leafs.only Should oly leaf solutions be considered, that is solutions having no extension in the dataframe
#' @param nodemaxsize,edgemaxwidth Graphic parameters 
#' @param main Title of the plot  
#' @return  An object that can be plotted by the \link{visIgraph} function. Note: this visualisation tools allows to move nodes interactively for a better inspection of the graph.
#' 
#' @examples
#' #Toy example
#' toy.matrix <- matrix(c(1,0,1,0,0,0,1,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,0,1),4,6,byrow=TRUE)
#' rownames(toy.matrix) <- LETTERS[1:4]
#' colnames(toy.matrix) <- letters[1:6]
#' toy.graph <- matrix2graph(toy.matrix)
#' reds <- c(rep(TRUE,3),rep(FALSE,3))
#' names(reds) <- colnames(toy.matrix)
#' sol <- solutions(toy.graph,reds)
#' g <- influenceGraph(sol,8,leafs.only=FALSE)
#' visIgraph(g)
#' 
#' #Real bladder data, restricted on the 20 first solution sets including only mutations
#' data("tcga_bladder",package="musette")   
#' reds= (groups == 'basal')
#' names(reds)=names(groups)
#' graph.muta <- matrix2graph(matrices$muta)
#' sol <- solutions(graph.muta,reds,bound=100)
#' g <- influenceGraph(sol,nb=20)
#' visIgraph(g)
#' 
#' #use with do.musette output including mutations, amplifications and deletions
#' cf vignette
#' 
#' @export influenceGraph
influenceGraph <- function(data,nb,do.musette.object=FALSE,leafs.only=TRUE,nodemaxsize=50,edgemaxwidth=30,main="Influence graph"){
   if (do.musette.object){
     g <- influenceGraph2(data$solutions,data$alterations,nb,leafs.only,nodemaxsize,edgemaxwidth,main)  
   } 
   else {
     g <- influenceGraph1(data,nb,leafs.only,nodemaxsize,edgemaxwidth,main) 
   } 
   return(g) 
}



#' Generating an Oncoplot of a Given Solution
#'
#' To be used with package ComplexHeatMap in order to visualize solutions as oncoplots.
#'
#' @param data A dataframe of solutions generated by \link{do.musette} 
#' @param index The index of a solution in a \code{\link{solutions}} dataframe
#' @param reds A named logical vector whose names are the samples' names. The
#' values are \code{TRUE} for red samples, i.e. those which the solution
#' should affect.
#' @param display A boolean value indicating if the corresponding oncoplot should be displayed 
#' @return  A matrix which can be used with function oncoPrint in package ComplexHeatmap to generate an oncoplot.
#' 
#' @examples 
#' #Real bladder data, restricted on the 20 first solution sets including only mutations
#' data("tcga_bladder",package="musette")   
#' reds= (groups == 'basal')
#' names(reds)=names(groups)
#' 
#' ll=do.musette(matrices=matrices, reds=reds, blind_domination_step = c("ampli","dele"), 
#' color_domination_step = c("ampli","dele"), blind_distance=5000000, 
#' color_distance=5000000, blind_percent=90, red_percent=80, 
#' blue_percent=80, chromosome = chromosome, longname=longname,
#' pathways=pathways,position=position, bound=20)
#' 
#' #oncomatrix for the best solution found so far in terms of score
#' 
#' index <- rownames(ll$solutions)[1]   
#' solution.oncomatrix(ll,index,reds)
#' 
#' 
#' @export

solution.oncomatrix<-function (data,index,reds,display=TRUE){
  alt.df <- data$alterations
  sol.df <- data$solutions
  profils=lapply(sol.df[[index,"alterations"]],function(g) ifelse(names(reds) %in% alt.df[[g,"neighbours"]],alt.df[[g,"type"]],""))
  ligne1=ifelse(reds,"red","")
  oncomatrix=do.call("rbind",c(list(ligne1),profils))
  rownames(oncomatrix)=c("reds",sol.df[[index,"alterations"]])
  colnames(oncomatrix)=names(reds)
  
  if(nrow(oncomatrix) >2 & display){
    oncomatrix_red <- oncomatrix[-1, reds]
    oncomatrix_blue <- oncomatrix[-1, !reds]
    
    alter_fun = list(
      background = function(x, y, w, h) {
        grid.rect(x, y, w-unit(2, "mm"), h-unit(0.5, "mm"), gp = gpar(fill = "#CCCCCC", col = NA))
      },
      dele = function(x, y, w, h) {
        grid.rect(x, y, w-unit(2, "mm"), h*0.8, gp = gpar(fill = "blue", col = NA))
      },
      ampli = function(x, y, w, h) {
        grid.rect(x, y, w-unit(2, "mm"), h*0.8, gp = gpar(fill = "red", col = NA))
      },
      muta = function(x, y, w, h) {
        grid.rect(x, y, w-unit(2, "mm"), h*0.33, gp = gpar(fill = "#008000", col = NA))
      },
      pseudo = function(x, y, w, h) {
        grid.rect(x, y, w-unit(2, "mm"), h*0.33, gp = gpar(fill = "black", col = NA))
      }
    )
    
    
    col = c(muta = "#008000", dele= "blue", ampli = "red", pseudo="black")
    ht_list <- oncoPrint(oncomatrix_red, get_type = function(x) strsplit(x, ";")[[1]],
                         alter_fun = alter_fun , col = col, 
                         column_title = paste("OncoPrint for solution number =", index,'\n', "(Pct of red =",round((ncol(oncomatrix_red)/(ncol(oncomatrix_red)+ ncol(oncomatrix_blue)))*100),"/ Pct of blue =" , 100-round((ncol(oncomatrix_red)/(ncol(oncomatrix_red)+ ncol(oncomatrix_blue)))*100), ")" ),
                         column_title_gp = gpar(fontsize = 16), row_names_gp = gpar(fontsize = 16), 
                         pct_gp = gpar(fontsize = 16),
                         alter_fun_is_vectorized = FALSE)
    
    
    ht_list1 <- oncoPrint(oncomatrix_blue, 
                          get_type = function(x) strsplit(x, ";")[[1]], 
                          alter_fun = alter_fun , col = col, 
                          show_row_names = FALSE, show_heatmap_legend=F, 
                          row_names_gp = gpar(fontsize = 16), pct_gp = gpar(fontsize = 16),
                          alter_fun_is_vectorized = FALSE)
    
    draw(ht_list + ht_list1, row_sub_title_side = "left", heatmap_legend_side = "bottom")
  }
  
  
  return(oncomatrix)
}













# en fonction de la valeur de la specificitÃ© de la solution. Attention: sol rangées par specificte pais influence bien sur base du score. C'est ce qu'on veut?

influenceGraph3 <- function (sol,alt, nb, leafs.only = TRUE, nodemaxsize = 50, edgemaxwidth = 30, 
                             main = "Influence graph") 
{
  if (leafs.only) {
    sol <- sol[sol$leaf == TRUE, ]
  }
  alt <- alt
  sol <- sol[order(sol$specificity, decreasing = TRUE), ]
  sol <- sol[1:min(nb, dim(sol)[1]), ]
  alterations <- do.call(c, sol$alterations)
  alterations <- unique(alterations)
  matsol <- c()
  adj_matsol <- matrix(0, length(alterations), length(alterations), 
                       dimnames = list(alterations, alterations))
  matsol = sapply(sol$alterations, function(s) alterations %in% 
                    s)
  for (i in 1:length(alterations)) {
    for (j in 1:length(alterations)) {
      common <- which(matsol[i, ] + matsol[j, ] == 2)
      adj_matsol[i, j] <- sum(sol$score[common])
    }
  }
  selected <- which(rowSums(adj_matsol) > 0)
  alt2 <- alt[alterations[selected],]
  net_mat <- adj_matsol[selected, selected]
  col_fun = circlize::colorRamp2(c(0,quantile(alt2$hyper, 0.90)), c(rgb(255, 255, 255, maxColorValue = 255),rgb(255, 0, 0, maxColorValue = 255)))
  g <- graph.adjacency(net_mat, mode = "undirected", weighted = TRUE, 
                       diag = FALSE)
  V(g)$size <- nodemaxsize * diag(net_mat)/max(diag(net_mat))
  V(g)$color.background <- col_fun(alt2$hyper)
  V(g)$color.border <- 'red'
  V(g)$color.highlight.background <- "rgb(255,253,56)"
  V(g)$color.highlight.border <- "rgb(253,164,41)"
  V(g)$color.hover.background <-  "rgb(255,253,56)"
  V(g)$color.hover.border <- "rgb(253,164,41)"
  V(g)$borderWidthSelected=10
  V(g)$label <- alterations[selected]
  V(g)$label.cex <- 0.8
  V(g)$font.color <- "rgb(49,127,230)"
  V(g)$font.highlight.color <- 'red'
  V(g)$title <- paste0("<p>", V(g)$label, "<br>band: ",alt2$band, "<br>Individual Score: ", round(alt2[,'score'], 2), "<br>R= ", alt2$nbredneighbours, '/', sol$red.total[1:nrow(alt2)],' - ','B= ',alt2$nbblueneighbours,'/', sol$blue.Total[1:nrow(alt2)], "</p>")
  # title = paste0("<p>", 1:nb,"<br>Tooltip !</p>")
  
  E(g)$width <- (edgemaxwidth * E(g)$weight/max(E(g)$weight))/2
  return(g)
}
